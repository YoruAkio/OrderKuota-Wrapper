name: Deploy Documentation

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy-gh-pages:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Generate HTML documentation
        run: bun run docs:generate:html

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./generated-temp/github-pages-html
          publish_branch: gh-pages
          force_orphan: true
          clean: true

  deploy-hashnode-docs:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Generate Markdown documentation
        run: bun run docs:generate:markdown

      - name: Check generated documentation
        run: |
          ls -la generated-temp/
          if [ -d "generated-temp/hashnode-markdown" ]; then
            echo "‚úÖ Hashnode markdown directory found"
            ls -la generated-temp/hashnode-markdown/
          else
            echo "‚ùå Hashnode markdown directory not found"
            exit 1
          fi

      - name: Create publish script
        run: |
          cat > publish-hashnode.js << 'EOF'
          import fs from 'fs';
          import path from 'path';
          
          const DOCS_DIR = './generated-temp/hashnode-markdown';
          const HASHNODE_API_URL = 'https://gql.hashnode.com/';
          
          async function publishToHashnode() {
            console.log('üîç Checking for markdown documentation...');
            
            if (!fs.existsSync(DOCS_DIR)) {
              console.error('‚ùå Markdown documentation directory not found at:', DOCS_DIR);
              console.log('Available directories:');
              try {
                const tempDir = './generated-temp';
                if (fs.existsSync(tempDir)) {
                  fs.readdirSync(tempDir).forEach(item => {
                    console.log('  -', item);
                  });
                } else {
                  console.log('  generated-temp directory does not exist');
                }
              } catch (e) {
                console.log('  Unable to list directories');
              }
              process.exit(1);
            }
            
            console.log('‚úÖ Found documentation directory');
            
            let allFiles = [];
            function findMarkdownFiles(dir, relativePath = '') {
              const items = fs.readdirSync(dir, { withFileTypes: true });
              for (const item of items) {
                const fullPath = path.join(dir, item.name);
                const relPath = path.join(relativePath, item.name);
                
                if (item.isDirectory()) {
                  findMarkdownFiles(fullPath, relPath);
                } else if (item.name.endsWith('.md') && !item.name.includes('README')) {
                  allFiles.push({ fullPath, relPath, name: item.name });
                }
              }
            }
            
            findMarkdownFiles(DOCS_DIR);
            
            console.log(`üìÑ Found ${allFiles.length} markdown files`);
            
            if (allFiles.length === 0) {
              console.log('‚ö†Ô∏è  No markdown files found to publish');
              return;
            }
            
            if (!process.env.HASHNODE_PAT) {
              console.log('‚ö†Ô∏è  HASHNODE_PAT not available, skipping publish');
              console.log('Available files that would be published:');
              allFiles.forEach(file => console.log(`  - ${file.relPath}`));
              return;
            }
            
            console.log(`üì§ Publishing ${allFiles.length} files to Hashnode...`);
            
            async function publishArticle(title, content, subtitle = '') {
              const mutation = `
                mutation PublishPost($input: PublishPostInput!) {
                  publishPost(input: $input) {
                    post {
                      id
                      title
                      url
                    }
                  }
                }
              `;
              
              const variables = {
                input: {
                  title: title,
                  subtitle: subtitle,
                  contentMarkdown: content,
                  tags: [
                    { slug: "api", name: "API" },
                    { slug: "documentation", name: "Documentation" },
                    { slug: "orderkuota", name: "OrderKuota" },
                    { slug: "nodejs", name: "Node.js" },
                    { slug: "typescript", name: "TypeScript" }
                  ],
                  publicationId: process.env.HASHNODE_PUBLICATION_ID || null,
                  publishedAt: new Date().toISOString()
                }
              };
              
              try {
                const response = await fetch(HASHNODE_API_URL, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': process.env.HASHNODE_PAT
                  },
                  body: JSON.stringify({
                    query: mutation,
                    variables: variables
                  })
                });
                
                const result = await response.json();
                
                if (result.errors) {
                  throw new Error(JSON.stringify(result.errors));
                }
                
                return result.data.publishPost.post;
              } catch (error) {
                throw new Error(`Failed to publish to Hashnode: ${error.message}`);
              }
            }
            
            for (const file of allFiles) {
              try {
                const content = fs.readFileSync(file.fullPath, 'utf8');
                const fileName = path.basename(file.name, '.md');
                const title = `OrderKuota API - ${fileName.replace(/-/g, ' ').replace(/([A-Z])/g, ' $1').trim()}`;
                const subtitle = 'Auto-generated API documentation for OrderKuota';
                
                console.log(`üìù Publishing: ${title}`);
                
                const post = await publishArticle(title, content, subtitle);
                
                console.log(`‚úÖ Successfully published: ${title}`);
                console.log(`üîó URL: ${post.url}`);
                
              } catch (error) {
                console.error(`‚ùå Failed to publish ${file.name}:`, error.message);
              }
            }
            
            console.log('üéâ Hashnode publishing completed!');
          }
          
          publishToHashnode().catch(console.error);
          EOF

      - name: Publish to Hashnode
        env:
          HASHNODE_PAT: ${{ secrets.HASHNODE_PAT }}
          HASHNODE_PUBLICATION_ID: ${{ secrets.HASHNODE_PUBLICATION_ID }}
        run: |
          if [ -z "$HASHNODE_PAT" ]; then
            echo "‚ö†Ô∏è  HASHNODE_PAT secret not found. Skipping Hashnode publishing."
            echo "üöÄ Running dry run to show what would be published..."
            bun run publish-hashnode.js
            exit 0
          fi
          
          echo "üöÄ Publishing documentation to Hashnode..."
          bun run publish-hashnode.js